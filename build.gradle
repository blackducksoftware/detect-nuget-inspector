buildscript {
    apply from: 'https://raw.githubusercontent.com/blackducksoftware/integration-resources/master/gradle_common/buildscript-repositories.gradle', to: buildscript
    apply from: 'https://raw.githubusercontent.com/blackducksoftware/integration-resources/master/gradle_common/buildscript-cgp-version.gradle'

    dependencies {
        classpath "com.blackduck.integration:common-gradle-plugin:${managedCgpVersion}"
    }
}

ext.dotNetExec = project.hasProperty('dotNetExec') ? project.getProperty('dotNetExec') : 'dotnet6'

group 'com.blackduck.integration'
version = '2.3.0-SIGQA3-SNAPSHOT'

apply plugin: 'com.blackduck.integration.solution'
apply plugin: 'distribution'

project.tasks.create(name: 'buildSolutions') {
    group 'dotnet build'
    description 'Build executable for all defined operating systems'
}

project.tasks.create(name: 'signWindowsExe') {
    group 'sign Windows Exe'
    description 'sign Executable files for all created windows executables'
}

project.tasks.create(name: 'testUnit', type: Exec){
    group 'dotnet test'
    description 'Run all Unit Tests defined inside detect-nuget-inspector-tests and generate test result'

    def buildCommand = [dotNetExec, 'test', 'detect-nuget-inspector/detect-nuget-inspector.sln','--logger:junit']
    doFirst {
        logger.lifecycle("Running Unit Tests")
    }
    doLast {
        logger.lifecycle("Output of unit tests located at ${buildDir}/detect-nuget-inspector/detect-nuget-inspector-tests/TestResults/TestResults.xml")
    }

    commandLine buildCommand
}

/*
The lines below will, for each configured solution
    * Create the build task
    * Create the distribution (zip) task
    * Set up dependencies to the build and distribution tasks
    * Add artifact to publishing
*/
HashMap<String, String> dotNetSolutions = ['mac': 'osx-x64', 'windows': 'win-x64', 'linux': 'linux-x64']

dotNetSolutions.each { os, buildCmd ->
    logger.lifecycle("Creating tasks for dotnet solution::" + os)

    String buildTaskName = "${os}BuildSolution"
    String buildOutputDir = "${buildDir}/tmp/${os}-build"
    project.tasks.create(name: buildTaskName, type: Exec) {
        group 'dotnet build'
        description "Create executable for ${os} in directory : ${buildOutputDir}"
        def buildCommand = [dotNetExec, 'publish', 'detect-nuget-inspector/detect-nuget-inspector.sln', '-r', "${buildCmd}", '-o', buildOutputDir, '--force']
        doFirst {
            logger.lifecycle("Running ${dotNetExec} for OS '${os}':: " + buildCommand.toString())
        }
        doLast {
            logger.lifecycle("Output of ${dotNetExec} for OS '${os}' located at:: " + buildOutputDir)
        }

        commandLine buildCommand
    }
    project.tasks.findByName('buildSolutions').dependsOn buildTaskName

    String signTaskName = "${os}SignTask"

    if (os == "windows") {
        project.tasks.create(name: signTaskName) {
            group 'sign Windows Exe'
            description 'sign Executable files for all created windows executables'
            dependsOn buildTaskName

            doLast {
                println("Starting the windows exe signing process")
                exec {
                    commandLine 'signing-client', '--username', "${System.getenv('SIGNING_USER')}", '--password', "env:SIGNING_TOKEN", '--server', "${System.getenv('SIGNING_SERVER')}", '--port', "${System.getenv('SIGNING_SERVER_PORT')}", '--signer', 'wininstaller', '--output', "${createArtifactName(buildOutputDir, os)}", "${createArtifactName(buildOutputDir, os)}"
                }
            }
        }

        project.tasks.findByName('signWindowsExe').dependsOn signTaskName
    }

    distributions {
        "${os}" {
            distributionBaseName = "${project.name}-${os}"
            contents {
                into("/")
                from { buildOutputDir }
            }
        }
    }
    String distributionTaskName = os + 'DistZip'
    project.tasks.findByName(distributionTaskName).doFirst { logger.lifecycle("Creating distribution zip from ${buildOutputDir} for OS '${os}'") }
    project.tasks.findByName(distributionTaskName) dependsOn buildTaskName
    project.tasks.findByName('distZip').dependsOn distributionTaskName

    publishing {
        publications {
            mavenZip(MavenPublication) {
                artifact(project.tasks.findByName(distributionTaskName)) {
                    classifier os
                    extension 'zip'
                }
            }
        }
    }
}

project.tasks.create(name: 'signMacExe') {
    group 'sign Mac Exe'
    description 'sign Executable files for all created mac executables'

    dependsOn distZip

    doLast {
        def currentDir = project.projectDir.absolutePath
        def signing_directory = "/signing"
        exec {
            commandLine 'docker', 'buildx', 'build', '-t', 'signing_image:latest', '--platform=linux/amd64', '--build-arg', "PYTHON_PYPI=${System.getenv('PYTHON_PYPI_URL')}", '.'
        }
        exec {
            commandLine 'docker', 'run', '--rm', '-v', "${currentDir}/build/distributions:${signing_directory}:rw", '-e', "SIGSC_USER=${System.getenv('SIGSC_USER')}", '-e', "SIGSC_PASSWORD=${System.getenv('SIGSC_PASSWORD')}", 'signing_image:latest', "${createArtifactName(signing_directory, "mac")}"
        }
    }
}

def createArtifactName(String dir, String osName) {
    if(osName == "windows") {
        return "${dir}/${project.name}.exe"
    } else if (osName == "mac") {
        return "/${dir}/${project.name}-${osName}-${project.version}.zip"
    }
}

artifactory {
    publish {
        defaults { publications('mavenZip') }
    }
}