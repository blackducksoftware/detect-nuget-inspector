buildscript {
    apply from: 'https://raw.githubusercontent.com/blackducksoftware/integration-resources/master/gradle_common/buildscript-repositories.gradle', to: buildscript
    apply from: 'https://raw.githubusercontent.com/blackducksoftware/integration-resources/master/gradle_common/buildscript-cgp-version.gradle'

    dependencies {
        classpath "com.blackduck.integration:common-gradle-plugin:${managedCgpVersion}"
    }
}

ext.dotNetExec = project.hasProperty('dotNetExec') ? project.getProperty('dotNetExec') : 'dotnet6'

group 'com.blackduck.integration'
version = '2.2.0-SNAPSHOT'

apply plugin: 'com.blackduck.integration.solution'
apply plugin: 'distribution'

project.tasks.create(name: 'buildSolutions') {
    group 'dotnet build'
    description 'Build executable for all defined operating systems'
}

project.tasks.create(name: 'signWindowsExe') {
    group 'sign Windows Exe'
    description 'sign Executable files for all created windows executables'
}

project.tasks.create(name: 'signMacExe') {
    group 'sign Mac Exe'
    description 'sign Executable files for all created mac executables'
}

project.tasks.create(name: 'testUnit', type: Exec){
    group 'dotnet test'
    description 'Run all Unit Tests defined inside detect-nuget-inspector-tests and generate test result'

    def buildCommand = [dotNetExec, 'test', 'detect-nuget-inspector/detect-nuget-inspector.sln','--logger:junit']
    doFirst {
        logger.lifecycle("Running Unit Tests")
    }
    doLast {
        logger.lifecycle("Output of unit tests located at ${buildDir}/detect-nuget-inspector/detect-nuget-inspector-tests/TestResults/TestResults.xml")
    }

    commandLine buildCommand
}

/*
The lines below will, for each configured solution
    * Create the build task
    * Create the distribution (zip) task
    * Set up dependencies to the build and distribution tasks
    * Add artifact to publishing
*/
HashMap<String, String> dotNetSolutions = ['mac': 'osx-x64', 'windows': 'win-x64', 'linux': 'linux-x64']

dotNetSolutions.each { os, buildCmd ->
    logger.lifecycle("Creating tasks for dotnet solution::" + os)

    String buildTaskName = "${os}BuildSolution"
    String buildOutputDir = "${buildDir}/tmp/${os}-build"
    project.tasks.create(name: buildTaskName, type: Exec) {
        group 'dotnet build'
        description "Create executable for ${os} in directory : ${buildOutputDir}"
        def buildCommand = [dotNetExec, 'publish', 'detect-nuget-inspector/detect-nuget-inspector.sln', '-r', "${buildCmd}", '-o', buildOutputDir, '--force']
        doFirst {
            logger.lifecycle("Running ${dotNetExec} for OS '${os}':: " + buildCommand.toString())
        }
        doLast {
            logger.lifecycle("Output of ${dotNetExec} for OS '${os}' located at:: " + buildOutputDir)
        }

        commandLine buildCommand
    }
    project.tasks.findByName('buildSolutions').dependsOn buildTaskName

    String signTaskName = "${os}SignTask"
    project.tasks.create(name: signTaskName) {
        group 'sign Windows Exe'
        description 'sign Executable files for all created windows executables'
        dependsOn buildTaskName
//        finalizedBy 'verifyExe'

        if(os == "windows") {
            doLast {
                exec {
                    commandLine 'signing-client', '--username', "${System.getenv('SIGNING_USER')}", '--password', "env:SIGNING_TOKEN", '--server', "${System.getenv('SIGNING_SERVER')}", '--port', "${System.getenv('SIGNING_SERVER_PORT')}", '--signer', 'wininstaller', '--output', "${createArtifactName(buildOutputDir, os)}", "${createArtifactName(buildOutputDir, os)}"
                }
            }
        }
    }

//    task verifyExe() {
//        dependsOn signExe
//        doLast {
//            exec {
//                // returns 0 if successfully verified as signed; non-0 if not
//                commandLine 'jarsigner', '-verify', '-strict', "${createArtifactName(buildOutputDir)}"
//            }
//        }
//    }

    String signZipTaskName = "${os}SignZipTask"
    project.tasks.create(name: signZipTaskName) {
        group 'sign Mac Exe'
        description 'sign Executable files for all created mac executables'
        dependsOn distZip
//        finalizedBy 'verifyExe'

        if(os == "mac") {
            doLast {
                exec {
                    commandLine "sh", "-c", """
                        DOCKER_BUILDKIT=0 docker build -t signing_image:latest --build-arg PYTHON_PYPI_URL=${System.getenv('PYTHON_PYPI_URL')} --build-arg OUTPUT_FILE_NAME=${createArtifactName(buildOutputDir, os)} -f Dockefile . &&
                        docker run signing_image:latest --mount type=bind,src=/,dst=/signing
                    """
                }
            }
        }
    }


    project.tasks.findByName('signWindowsExe').dependsOn signTaskName

    project.tasks.findByName('signMacExe').dependsOn signZipTaskName

    distributions {
        "${os}" {
            distributionBaseName = "${project.name}-${os}"
            contents {
                into("/")
                from { buildOutputDir }
            }
        }
    }
    String distributionTaskName = os + 'DistZip'
    project.tasks.findByName(distributionTaskName).doFirst { logger.lifecycle("Creating distribution zip from ${buildOutputDir} for OS '${os}'") }
    project.tasks.findByName(distributionTaskName) dependsOn buildTaskName
    project.tasks.findByName('distZip').dependsOn distributionTaskName

    publishing {
        publications {
            mavenZip(MavenPublication) {
                artifact(project.tasks.findByName(distributionTaskName)) {
                    classifier os
                    extension 'zip'
                }
            }
        }
    }
}

def createArtifactName(String buildOutputDir, String osName) {
    if(osName == "windows") {
        return "${buildOutputDir}/${project.name}.exe"
    } else if (osName == "mac") {
        return "${project.name}-${project.version}-${osName}.zip"
    }
}


artifactory {
    publish {
        defaults { publications('mavenZip') }
    }
}